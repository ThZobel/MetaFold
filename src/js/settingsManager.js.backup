// Settings Manager - Complete Version with Secure Storage + All elabFTW Methods

const settingsManager = {
    settings: {},
    secureCredentials: {}, // Separate storage for encrypted credentials
    isSecureStorageReady: false,
    migrationStatus: {
        completed: false,
        lastMigration: null,
        migratedKeys: []
    },
    
    defaultSettings: {
        // General Settings
        'general.user_management_enabled': false,
        'general.theme': 'dark',
        'general.auto_save': true,
        'general.show_tips': true,
        
        // Security Settings
        'security.encryption_enabled': true,
        'security.auto_migrate': true,
        'security.require_encryption': false,
        
        // elabFTW Integration Settings
        'elabftw.enabled': false,
        'elabftw.server_url': '',
        'elabftw.api_key': '', // Will be moved to secure storage
        'elabftw.auto_sync': false,
        'elabftw.default_category': 1,
        'elabftw.verify_ssl': true,
        
        // OMERO Integration Settings
        'omero.enabled': false,
        'omero.server_url': '',
        'omero.username': '', // Will be moved to secure storage
        'omero.password': '', // Will be moved to secure storage
        'omero.auto_sync': false,
        'omero.default_project_id': '',
        'omero.create_datasets': true,
        'omero.verify_ssl': true,
        'omero.session_timeout': 600000 // 10 minutes
    },

    // Keys that should be stored securely
    sensitiveKeys: [
        'elabftw.api_key',
        'omero.password',
        'omero.username'
    ],

    // =================== INITIALIZATION ===================

    async init() {
        console.log('üîß Initializing settingsManager with Secure Storage...');
        
        // Initialize secure storage first
        if (window.secureStorage) {
            try {
                await window.secureStorage.init();
                this.isSecureStorageReady = true;
                console.log('üîê Secure storage ready');
            } catch (error) {
                console.warn('üîê Secure storage initialization failed:', error);
                this.isSecureStorageReady = false;
            }
        }
        
        // Load settings
        this.loadSettings();
        
        // Load secure credentials
        await this.loadSecureCredentials();
        
        // Check if migration is needed
        await this.checkAndPerformMigration();
        
        // Apply initial settings
        this.applyInitialSettings();
        
        console.log('‚úÖ settingsManager initialized with secure storage support');
    },

    // =================== SECURE CREDENTIAL MANAGEMENT ===================

    async loadSecureCredentials() {
        try {
            const storedCredentials = localStorage.getItem('metafold_secure_credentials');
            if (storedCredentials) {
                this.secureCredentials = JSON.parse(storedCredentials);
                console.log('üîê Loaded secure credentials store');
            }
            
            // Load migration status
            const migrationStatus = localStorage.getItem('metafold_migration_status');
            if (migrationStatus) {
                this.migrationStatus = { ...this.migrationStatus, ...JSON.parse(migrationStatus) };
            }
        } catch (error) {
            console.warn('üîê Error loading secure credentials:', error);
            this.secureCredentials = {};
        }
    },

    async saveSecureCredentials() {
        try {
            localStorage.setItem('metafold_secure_credentials', JSON.stringify(this.secureCredentials));
            localStorage.setItem('metafold_migration_status', JSON.stringify(this.migrationStatus));
            console.log('üîê Saved secure credentials store');
        } catch (error) {
            console.error('üîê Error saving secure credentials:', error);
        }
    },

    async setSecureCredential(key, value) {
        if (!this.isSecureStorageReady) {
            console.warn('üîê Secure storage not ready, storing as plaintext');
            return this.set(key, value);
        }

        if (!value || value.trim() === '') {
            // Remove credential if empty
            delete this.secureCredentials[key];
            await this.saveSecureCredentials();
            console.log(`üîê Removed secure credential: ${key.replace(/password|key/gi, '***')}`);
            return true;
        }

        try {
            const encrypted = await window.secureStorage.storeCredential(key, value, {
                key: key,
                timestamp: new Date().toISOString(),
                source: 'settings'
            });

            this.secureCredentials[key] = encrypted;
            await this.saveSecureCredentials();
            
            console.log(`üîê Stored secure credential: ${key.replace(/password|key/gi, '***')} using ${encrypted.method}`);
            return true;
        } catch (error) {
            console.error(`üîê Failed to store secure credential ${key}:`, error);
            
            // Fallback to plaintext if encryption fails
            console.warn('üîê Falling back to plaintext storage');
            return this.set(key, value);
        }
    },

    async getSecureCredential(key) {
        // Check if credential is stored securely
        if (this.secureCredentials[key]) {
            try {
                const decrypted = await window.secureStorage.retrieveCredential(this.secureCredentials[key]);
                console.log(`üîê Successfully decrypted ${key}:`, decrypted ? `${decrypted.substring(0, 4)}*** (${decrypted.length} chars)` : 'EMPTY');
                return decrypted || '';
            } catch (error) {
                console.error(`üîê Failed to decrypt credential ${key}:`, error);
                
                // FIXED: Fallback to plaintext setting WITHOUT recursion
                const plaintextValue = this.settings[key] !== undefined ? this.settings[key] : this.defaultSettings[key];
                console.warn(`üîê Using plaintext fallback for ${key}:`, plaintextValue ? `${String(plaintextValue).substring(0, 4)}*** (${String(plaintextValue).length} chars)` : 'EMPTY');
                return plaintextValue || '';
            }
        }
        
        // FIXED: Fallback to regular settings WITHOUT recursion
        const regularValue = this.settings[key] !== undefined ? this.settings[key] : this.defaultSettings[key];
        console.log(`üîê No secure credential for ${key}, using regular setting:`, regularValue ? `${String(regularValue).substring(0, 4)}*** (${String(regularValue).length} chars)` : 'EMPTY');
        return regularValue || '';
    },

    // =================== MIGRATION LOGIC ===================

    async checkAndPerformMigration() {
        if (this.migrationStatus.completed || !this.isSecureStorageReady) {
            return;
        }

        console.log('üîÑ Checking for credential migration...');
        
        const shouldAutoMigrate = this.get('security.auto_migrate');
        let needsMigration = false;
        const plaintextCredentials = {};

        // Check for plaintext sensitive data
        for (const key of this.sensitiveKeys) {
            const value = this.settings[key];
            if (value && typeof value === 'string' && value.trim() !== '') {
                needsMigration = true;
                plaintextCredentials[key] = value;
            }
        }

        if (!needsMigration) {
            console.log('üîÑ No migration needed');
            return;
        }

        if (shouldAutoMigrate) {
            console.log('üîÑ Auto-migrating credentials...');
            await this.performMigration(plaintextCredentials);
        } else {
            console.log('üîÑ Migration needed but auto-migrate disabled');
            this.showMigrationPrompt(plaintextCredentials);
        }
    },

    async performMigration(plaintextCredentials) {
        try {
            console.log('üîÑ Starting credential migration...');
            const migrationLog = [];

            for (const [key, value] of Object.entries(plaintextCredentials)) {
                try {
                    await this.setSecureCredential(key, value);
                    
                    // Remove from plaintext settings
                    delete this.settings[key];
                    
                    migrationLog.push({
                        key: key.replace(/password|key/gi, '***'),
                        success: true,
                        method: this.secureCredentials[key]?.method || 'unknown'
                    });
                    
                    console.log(`üîÑ Migrated: ${key.replace(/password|key/gi, '***')}`);
                } catch (error) {
                    migrationLog.push({
                        key: key.replace(/password|key/gi, '***'),
                        success: false,
                        error: error.message
                    });
                    console.error(`üîÑ Migration failed for ${key}:`, error);
                }
            }

            // Update migration status
            this.migrationStatus = {
                completed: true,
                lastMigration: new Date().toISOString(),
                migratedKeys: migrationLog.filter(log => log.success).map(log => log.key),
                migrationLog: migrationLog
            };

            // Save both stores
            this.saveSettings();
            await this.saveSecureCredentials();
            
            const successCount = migrationLog.filter(log => log.success).length;
            console.log(`‚úÖ Migration completed: ${successCount}/${migrationLog.length} credentials migrated`);
            
            this.showMigrationSuccess(migrationLog);
            
        } catch (error) {
            console.error('‚ùå Migration failed:', error);
            this.showMigrationError(error);
        }
    },

    showMigrationPrompt(plaintextCredentials) {
        const credentialCount = Object.keys(plaintextCredentials).length;
        const message = `MetaFold found ${credentialCount} unencrypted credential(s) in your settings. Would you like to encrypt them for better security?`;
        
        if (confirm(message)) {
            this.performMigration(plaintextCredentials);
        } else {
            console.log('üîÑ Migration declined by user');
        }
    },

    showMigrationSuccess(migrationLog) {
        const successCount = migrationLog.filter(log => log.success).length;
        this.showSecurityMessage(
            `üîê Security Enhanced! ${successCount} credentials have been encrypted and are now stored securely.`,
            'success'
        );
    },

    showMigrationError(error) {
        this.showSecurityMessage(
            `‚ö†Ô∏è Credential migration failed: ${error.message}. Your data remains in plaintext.`,
            'warning'
        );
    },

    // =================== ENHANCED SETTINGS METHODS ===================

    loadSettings() {
        try {
            const stored = localStorage.getItem('metafold_settings');
            if (stored) {
                this.settings = { ...this.defaultSettings, ...JSON.parse(stored) };
            } else {
                this.settings = { ...this.defaultSettings };
            }
            console.log('üìÇ Settings loaded');
        } catch (error) {
            console.warn('Error loading settings, using defaults:', error);
            this.settings = { ...this.defaultSettings };
        }
    },

    saveSettings() {
        try {
            localStorage.setItem('metafold_settings', JSON.stringify(this.settings));
            console.log('üíæ Settings saved successfully');
            return true;
        } catch (error) {
            console.error('Error saving settings:', error);
            return false;
        }
    },

    async get(key) {
        // Check if this is a sensitive key that should be retrieved securely
        if (this.sensitiveKeys.includes(key)) {
            return await this.getSecureCredential(key);
        }
        
        // Regular setting retrieval
        const value = this.settings[key] !== undefined ? this.settings[key] : this.defaultSettings[key];
        return value;
    },

    async set(key, value) {
        console.log(`üìù Set setting "${key}":`, this.sensitiveKeys.includes(key) ? '[HIDDEN]' : value);
        
        // Check if this is a sensitive key that should be stored securely
        if (this.sensitiveKeys.includes(key) && this.isSecureStorageReady) {
            const success = await this.setSecureCredential(key, value);
            if (success) {
                this.handleSettingChange(key, value);
            }
            return success;
        }
        
        // Regular setting storage
        this.settings[key] = value;
        const saved = this.saveSettings();
        
        if (saved) {
            this.handleSettingChange(key, value);
        }
        
        return saved;
    },

    // =================== ELABFTW INTEGRATION (ALL METHODS) ===================

    // Test elabFTW connection
    async testElabFTWConnection() {
        const serverUrl = await this.get('elabftw.server_url');
        const apiKey = await this.get('elabftw.api_key');
        
        if (!serverUrl || !apiKey) {
            return { success: false, message: 'Server URL and API key are required' };
        }

        const formattedUrl = await this.getFormattedElabFTWUrl();

        try {
            const response = await fetch(`${formattedUrl}api/v2/users/me`, {
                headers: {
                    'Authorization': apiKey,
                    'Content-Type': 'application/json'
                }
            });

            if (response.ok) {
                const data = await response.json();
                return { 
                    success: true, 
                    message: `Connected successfully as ${data.fullname || 'Unknown User'}` 
                };
            } else {
                return { 
                    success: false, 
                    message: `Connection failed: ${response.status} ${response.statusText}` 
                };
            }
        } catch (error) {
            return { 
                success: false, 
                message: `Connection error: ${error.message}` 
            };
        }
    },

    // Create elabFTW experiment
    async createElabFTWExperiment(projectName, metadata, structure = '') {
        const serverUrl = await this.getFormattedElabFTWUrl();
        const apiKey = await this.get('elabftw.api_key');
        const categoryId = await this.get('elabftw.default_category');
        
        if (!serverUrl || !apiKey) {
            return { success: false, message: 'elabFTW not configured' };
        }

        try {
            const experimentData = {
                title: projectName,
                body: this.generateExperimentBody(projectName, metadata, structure)
            };

            if (categoryId && categoryId !== '') {
                experimentData.category_id = parseInt(categoryId);
            }

            const response = await fetch(`${serverUrl}api/v2/experiments`, {
                method: 'POST',
                headers: {
                    'Authorization': apiKey,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(experimentData)
            });

            if (response.ok || response.status === 201) {
                const location = response.headers.get('location');
                const experimentId = location ? location.split('/').pop() : null;
                
                if (metadata && Object.keys(metadata).length > 0 && experimentId) {
                    await this.updateExperimentWithMetadata(serverUrl, apiKey, experimentId, metadata);
                }
                
                return {
                    success: true,
                    message: 'Experiment created in elabFTW successfully!',
                    id: experimentId,
                    url: `${serverUrl}experiments.php?mode=view&id=${experimentId}`
                };
            } else {
                const errorText = await response.text();
                return {
                    success: false,
                    message: `elabFTW API error: ${response.status} - ${errorText}`
                };
            }
        } catch (error) {
            return {
                success: false,
                message: `Error creating elabFTW experiment: ${error.message}`
            };
        }
    },

    // Update existing elabFTW experiment
    async updateExistingElabFTWExperiment(experimentId, metadata) {
        const serverUrl = await this.getFormattedElabFTWUrl();
        const apiKey = await this.get('elabftw.api_key');
        
        if (!serverUrl || !apiKey) {
            return { success: false, message: 'elabFTW not configured' };
        }

        try {
            const elabftwFields = this.convertMetadataToElabFTW(metadata);
            const metadataString = JSON.stringify({
                elabftw: {
                    display_main_text: true
                },
                extra_fields: elabftwFields
            });

            const updateData = {
                metadata: metadataString
            };

            const response = await fetch(`${serverUrl}api/v2/experiments/${experimentId}`, {
                method: 'PATCH',
                headers: {
                    'Authorization': apiKey,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(updateData)
            });

            if (response.ok) {
                const experimentUrl = `${serverUrl}experiments.php?mode=view&id=${experimentId}`;
                
                return {
                    success: true,
                    message: `Experiment ${experimentId} updated in elabFTW`,
                    id: experimentId,
                    url: experimentUrl
                };
            } else {
                const errorText = await response.text();
                return {
                    success: false,
                    message: `elabFTW API error: ${response.status} - ${errorText}`
                };
            }
        } catch (error) {
            return {
                success: false,
                message: `Error updating elabFTW experiment: ${error.message}`
            };
        }
    },

    // Get formatted elabFTW URL
    async getFormattedElabFTWUrl() {
        const serverUrl = await this.get('elabftw.server_url');
        if (!serverUrl) return null;

        let formattedUrl = serverUrl.trim();
        if (!formattedUrl.startsWith('http://') && !formattedUrl.startsWith('https://')) {
            formattedUrl = 'https://' + formattedUrl;
        }
        if (!formattedUrl.endsWith('/')) {
            formattedUrl += '/';
        }
        return formattedUrl;
    },

    // Update experiment with metadata using PATCH
    async updateExperimentWithMetadata(serverUrl, apiKey, experimentId, metadata) {
        try {
            const elabftwFields = this.convertMetadataToElabFTW(metadata);
            const metadataString = JSON.stringify({
                elabftw: {
                    display_main_text: true
                },
                extra_fields: elabftwFields
            });

            const updateData = {
                metadata: metadataString
            };

            const response = await fetch(`${serverUrl}api/v2/experiments/${experimentId}`, {
                method: 'PATCH',
                headers: {
                    'Authorization': apiKey,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(updateData)
            });

            if (response.ok) {
                console.log('‚úÖ Metadata successfully added to experiment');
                return true;
            } else {
                const errorText = await response.text();
                console.error('‚ùå Failed to update experiment metadata:', response.status, errorText);
                return false;
            }
        } catch (error) {
            console.error('‚ùå Error updating experiment metadata:', error);
            return false;
        }
    },

    // Convert MetaFold metadata to elabFTW format
    convertMetadataToElabFTW(metadata) {
        const elabftwFields = {};
        
        Object.entries(metadata).forEach(([key, fieldInfo]) => {
            if (fieldInfo.type === 'group') return;

            const elabField = {
                type: this.mapFieldTypeToElabFTW(fieldInfo.type),
                value: this.formatValueForElabFTW(fieldInfo.value, fieldInfo.type)
            };

            if (fieldInfo.description) {
                elabField.description = fieldInfo.description;
            }

            if (fieldInfo.required) {
                elabField.required = true;
            }

            if (fieldInfo.type === 'textarea') {
                elabField.multiline = true;
            }

            if (fieldInfo.type === 'dropdown' && fieldInfo.options) {
                elabField.options = fieldInfo.options.map(opt => String(opt));
            }

            if (fieldInfo.type === 'number') {
                if (fieldInfo.min !== undefined) elabField.min = fieldInfo.min;
                if (fieldInfo.max !== undefined) elabField.max = fieldInfo.max;
            }

            const fieldKey = fieldInfo.label || key;
            elabftwFields[fieldKey] = elabField;
        });

        return elabftwFields;
    },

    // Map field types to elabFTW types
    mapFieldTypeToElabFTW(type) {
        const typeMap = {
            'text': 'text',
            'number': 'number',
            'date': 'date',
            'textarea': 'text',
            'dropdown': 'select',
            'checkbox': 'checkbox'
        };
        
        return typeMap[type] || 'text';
    },

    // Format values for elabFTW
    formatValueForElabFTW(value, type) {
        switch (type) {
            case 'checkbox':
                return (value === true || value === 'true' || value === 'on') ? "on" : "";
            case 'number':
                return String(value !== undefined && value !== null && value !== '' ? value : 0);
            case 'dropdown':
                return String(value || '');
            default:
                return String(value || '');
        }
    },

    // Generate experiment body for elabFTW
    generateExperimentBody(projectName, metadata, structure = '') {
        const date = new Date().toLocaleDateString('en-US', { 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric' 
        });
        
        let body = `<h1>${projectName}</h1>\n\n`;
        body += `<p><strong>Created:</strong> ${date}</p>\n\n`;
        
        if (metadata && Object.keys(metadata).length > 0) {
            body += `<h2>Experiment Metadata</h2>\n<ul>\n`;
            
            Object.entries(metadata).forEach(([key, fieldInfo]) => {
                if (fieldInfo.type !== 'group') {
                    const value = fieldInfo.value || 'Not filled';
                    const label = fieldInfo.label || key;
                    
                    if (fieldInfo.type === 'checkbox') {
                        const checkValue = (value === true || value === 'true' || value === 'on') ? '‚úÖ Yes' : '‚ùå No';
                        body += `<li><strong>${label}:</strong> ${checkValue}</li>\n`;
                    } else {
                        body += `<li><strong>${label}:</strong> ${value}</li>\n`;
                    }
                }
            });
            
            body += `</ul>\n\n`;
        }
        
        if (structure && structure.trim() !== '') {
            body += `<h2>Project Structure</h2>\n<pre>${structure}</pre>\n\n`;
        }
        
        body += `<h2>Description</h2>\n<p><em>Add your project description here...</em></p>\n\n`;
        body += `<h2>Methodology</h2>\n<p><em>Describe your methodology here...</em></p>\n\n`;
        body += `<h2>Results</h2>\n<p><em>Document your results here...</em></p>\n\n`;
        body += `<h2>Notes</h2>\n<p><em>Add any additional notes here...</em></p>\n`;
        
        return body;
    },

    // =================== OMERO INTEGRATION ===================

    async testOMEROConnection() {
        if (!window.omeroUIIntegration) {
            return { success: false, message: 'OMERO UI integration module not available' };
        }
        
        try {
            return await window.omeroUIIntegration.testConnection();
        } catch (error) {
            return { 
                success: false, 
                message: `OMERO connection test failed: ${error.message}` 
            };
        }
    },

    async createOMERODataset(projectName, metadata, options = {}) {
        if (!window.metaFoldOMEROIntegration) {
            return { success: false, message: 'MetaFold OMERO integration module not available' };
        }
        
        try {
            console.log('üî¨ settingsManager: Delegating to metaFoldOMEROIntegration.createDatasetForMetaFoldProject');
            console.log('üî¨ Parameters:', { projectName, metadataKeys: metadata ? Object.keys(metadata) : 'none', options });
            
            return await window.metaFoldOMEROIntegration.createDatasetForMetaFoldProject(projectName, metadata, options);
        } catch (error) {
            console.error('‚ùå settingsManager: Error in createOMERODataset:', error);
            return {
                success: false,
                message: `Error creating OMERO dataset: ${error.message}`
            };
        }
    },

    // =================== SECURITY STATUS METHODS ===================

    getSecurityStatus() {
        if (!window.secureStorage) {
            return {
                available: false,
                status: 'not_available',
                message: 'Secure storage module not loaded'
            };
        }

        const storageStatus = window.secureStorage.getStatus();
        const encryptedCount = Object.keys(this.secureCredentials).length;
        const plaintextCount = this.sensitiveKeys.filter(key => 
            this.settings[key] && typeof this.settings[key] === 'string'
        ).length;

        return {
            available: storageStatus.initialized,
            method: storageStatus.bestMethod,
            capabilities: storageStatus.capabilities,
            encryptedCredentials: encryptedCount,
            plaintextCredentials: plaintextCount,
            migrationCompleted: this.migrationStatus.completed,
            status: plaintextCount > 0 ? 'needs_migration' : 'secure'
        };
    },

    showSecurityMessage(message, type = 'info') {
        let messageDiv = document.getElementById('securityStatusMessage');
        if (!messageDiv) {
            messageDiv = document.createElement('div');
            messageDiv.id = 'securityStatusMessage';
            messageDiv.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                padding: 12px 20px;
                border-radius: 8px;
                z-index: 10001;
                font-weight: 500;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                max-width: 400px;
            `;
            document.body.appendChild(messageDiv);
        }
        
        const styles = {
            'info': { bg: '#dbeafe', color: '#1e40af', border: '#60a5fa' },
            'success': { bg: '#d1fae5', color: '#065f46', border: '#34d399' },
            'warning': { bg: '#fef3c7', color: '#92400e', border: '#fbbf24' },
            'error': { bg: '#fee2e2', color: '#b91c1c', border: '#f87171' }
        };
        
        const style = styles[type] || styles.info;
        messageDiv.style.background = style.bg;
        messageDiv.style.color = style.color;
        messageDiv.style.border = `1px solid ${style.border}`;
        
        messageDiv.textContent = message;
        messageDiv.style.display = 'block';
        
        setTimeout(() => {
            if (messageDiv.parentElement) {
                messageDiv.remove();
            }
        }, 8000);
    },

    // =================== MIGRATION UTILITIES ===================

    async forceMigration() {
        this.migrationStatus.completed = false;
        await this.checkAndPerformMigration();
    },

    async exportSecureSettings() {
        const securityStatus = this.getSecurityStatus();
        
        return {
            settings: this.settings,
            securityStatus: securityStatus,
            migrationStatus: this.migrationStatus,
            hasEncryptedCredentials: Object.keys(this.secureCredentials).length > 0,
            exportTimestamp: new Date().toISOString(),
            warning: 'This export does not contain encrypted credentials for security reasons'
        };
    },

    async resetSecurity() {
        if (confirm('Reset all security settings and credentials? This will remove all encrypted data!')) {
            this.secureCredentials = {};
            this.migrationStatus = {
                completed: false,
                lastMigration: null,
                migratedKeys: []
            };
            
            // Move secure credentials back to plaintext (for this session only)
            for (const key of this.sensitiveKeys) {
                const value = await this.getSecureCredential(key);
                if (value) {
                    this.settings[key] = value;
                }
            }
            
            await this.saveSecureCredentials();
            this.saveSettings();
            
            this.showSecurityMessage('üîÑ Security settings reset. Credentials are now in plaintext.', 'warning');
        }
    },

    // =================== LEGACY COMPATIBILITY ===================

    applyInitialSettings() {
        const theme = this.settings['general.theme'];
        if (theme) {
            this.applyTheme(theme);
        }
    },

    handleSettingChange(key, value) {
        switch (key) {
            case 'general.user_management_enabled':
                this.handleUserManagementToggle(value);
                break;
                
            case 'general.theme':
                this.applyTheme(value);
                break;
                
            case 'elabftw.enabled':
            case 'elabftw.auto_sync':
                if (window.updateElabFTWOptions) {
                    window.updateElabFTWOptions();
                }
                break;
                
            case 'omero.enabled':
            case 'omero.auto_sync':
                if (window.updateOMEROOptions) {
                    window.updateOMEROOptions();
                }
                break;
        }
    },

    applyTheme(theme) {
        console.log('üé® Theme changed to:', theme);
    },

    handleUserManagementToggle(enabled) {
        console.log(`üë• User management ${enabled ? 'enabled' : 'disabled'}`);
        
        if (enabled) {
            this.showSecurityMessage(
                'üë• User Management enabled! Initializing login system...',
                'info'
            );
        } else {
            this.showSecurityMessage(
                'üìù Simple mode enabled. Changes will take effect after restart.',
                'info'
            );
        }
    },

    reset() {
        console.log('üîÑ Resetting settings to defaults...');
        
        if (Object.keys(this.secureCredentials).length > 0) {
            if (confirm('This will also remove all encrypted credentials. Continue?')) {
                this.secureCredentials = {};
                this.saveSecureCredentials();
            } else {
                return;
            }
        }
        
        this.settings = { ...this.defaultSettings };
        this.saveSettings();
        this.applyInitialSettings();
    },

    export() {
        return this.exportSecureSettings();
    },

    import(settingsJson) {
        try {
            const imported = JSON.parse(settingsJson);
            this.settings = { ...this.defaultSettings, ...imported.settings || imported };
            const saved = this.saveSettings();
            
            if (saved) {
                this.applyInitialSettings();
                this.showSecurityMessage(
                    'Settings imported. Encrypted credentials were not imported for security.',
                    'info'
                );
            }
            
            return saved;
        } catch (error) {
            console.error('Error importing settings:', error);
            return false;
        }
    },

    isUserManagementEnabled() {
        return this.settings['general.user_management_enabled'] === true;
    }
};

window.settingsManager = settingsManager;
console.log('‚úÖ settingsManager loaded with Complete elabFTW + OMERO + Secure Storage support');